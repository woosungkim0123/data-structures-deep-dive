# 자료구조 전 알아두면 좋은 지식

## 자료구조와 알고리즘 기초

데이터를 효율적으로 저장하고 조직화하는 방법에 중점을 두는 자료 구조와 문제를 빠르고 정확하게 해결하는 방법에 중점을 두는 알고리즘은 컴퓨터 과학의 두 핵심 요소입니다. 

### 시간복잡도 & 공간 복잡도

시간 복잡도와 공간 복잡도는 알고리즘의 효율성을 평가하는 두 가지 중요한 지표입니다. 

시간 복잡도는 알고리즘이 문제를 해결하는 데 소요되는 시간의 양 측정하는 것이며, 공간 복잡도는 알고리즘이 사용하는 메모리의 양을 측정합니다.

이때 최악의 경우를 가정하여 시간 복잡도와 공간 복잡도를 측정하는 빅오 표기법(Big-O Notation)이 널리 사용됩니다.

**빅오 표기법**

알고리즘의 성능을 나타내는 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시하며, 계수는 생략하여 표시하는 방식입니다.

**시간복잡도 종류**

| 이름 | 표기법 |
| ---- | ---- |
| 상수(Constant) 시간 | O(1) |
| 로그(logarithmic) 시간 | O(logN) |
| 선형(linear) 시간 | O(N) |
| N 로그 N(N Log N) 시간 | O(NlogN) |
| 이차(quadratic) 시간 | O(N^2) |
| 지수(exponential) 시간 | O(2^N) |
| N제곱(N-power-n) 시간 | O(N^n) |
| 계승(factorial) | O(N!) |

**0(1)과 0(n)**

0(N)은 데이터가 늘어나면 연산 횟수도 함께 선형적으로 늘어나지만 0(1)은 데이터가 아무리 늘어나도 항상 연산하는 횟수는 일정합니다.

![0(1)과 0(n)](image/1_n.png)

**0(n^2)**

```c
int search(int N)
{
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
	return 0;
}
```

![0(n^2)](image/n^2.png)

**0(log n)**

데이터가 많아지면 많아질 수록 연산 횟수가 급격하게 떨어집니다.

절반씩 나눠가며 검색하는 알고리즘은 0(logN)의 시간 복잡도를 가집니다.

이때 log는 밑이 2인 로그를 의미합니다.

```c
int main(int N)
{
	for (int i = 0; i < N; i / 2) // 반씩 줄어들면서
	return 0;
}
```

![0(log n)](image/log_n.png)

**데이터 수로 확인하는 시간복잡도**

| n | 0(n) | 0(log n) |
|---|------|----------|
| 10 | 10   | log10 = 4 |
| 100 | 100  | log100 = 7 |
| 1000 | 1000 | log1000 = 10 |
|1000000|1000000| log1000000 = 20 |

### 선형(linear) 구조

선형 구조란 자료를 구성하는 원소들을 하나씩 순차적으로 나열하여 관리하는 방식입니다. 선형 구조에서는 자료들간의 앞, 뒤 관계가 1대1 관계입니다.

선형 구조의 대표적인 예로는 스택, 큐 등이 있습니다.

### 비선형(non-linear) 구조

비선형 구조는 하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 구조입니다. 비선형 구조에서는 자료들간의 앞, 뒤 관계가 1대N 또는 N대N 관계입니다.

비선형 구조의 대표적인 예로는 트리, 그래프 등이 있습니다.

### 추상 자료형(ADT, Abstract Data Type)와 자료구조 차이

추상 자료형(ADT)은 데이터와 그에 대한 연산들을 추상적으로 정의합니다. 구체적인 구현을 포함하지 않고, 인터페이스 형태로만 표현됩니다. 

반면, 자료구조는 이러한 ADT를 구현하는 구체적인 메커니즘을 제공하며, 실제로 데이터가 메모리에 어떻게 저장되고 조작되는지를 정의합니다. 

간단한 예시로, 스택과 큐는 ADT로서의 역할을 하며, 이들을 실제로 구현하는 자료구조로는 배열 기반 스택, 연결 리스트 기반 스택, 배열 기반 큐, 연결 리스트 기반 큐 등이 있습니다.

## 메모리 구조

![메모리 구조](image/memory_structure.png)

### 스택(Stack)

스택 영역은 프로그램의 실행 중 함수 호출과 관련된 정보를 저장하는 메모리 영역입니다. 이 영역에서는 각 함수 호출에 대한 스택 프레임(Stack Frame)이 관리됩니다. 스택 프레임은 특정 함수 호출과 관련된 정보를 담고 있으며, 각각의 함수 호출 시마다 새로운 스택 프레임이 생성되어 스택에 추가(push)됩니다.

각 스택 프레임은 다음과 같은 정보를 포함 합니다:

- 지역변수(Local Variables): 해당 함수 내에서 선언되고 사용되는 변수들.
- 매개변수(Parameters): 함수를 호출할 때 전달되는 인수들.
- 복귀 주소(Return Address): 함수가 작업을 마치고 리턴할 때, 제어를 넘겨줄 코드의 주소.
- 기타 컨텍스트 정보: 함수의 실행 상태를 유지하기 위한 추가 정보들, 예를 들어 CPU 레지스터의 상태 등.

함수가 종료되고 리턴될 때, 해당 스택 프레임은 스택에서 제거(pop)되며, 제어는 복귀 주소에 지정된 코드 위치로 이동합니다. 이러한 스택의 동작 방식은 후입선출(LIFO, Last-In, First-Out) 원칙을 따릅니다.

### 데이터(Data)

전역 변수와 정적(static) 변수가 저장되는 영역입니다. 프로그램의 시작과 함께 할당되고 프로그램이 종료될 때 해제됩니다.

이 영역의 변수들은 프로그램의 생명주기와 동일하며, 초기화된 데이터와 초기화되지 않은 데이터로 더 세분화될 수 있습니다.

### 코드(Code)

프로그램의 코드가 저장되는 영역입니다. 코드 영역은 텍스트 영역이라고도 불리며, 실행할 프로그램의 명령어들이 기계어의 형태로 저장됩니다.

코드 영역은 읽기 전용으로 설정되어 있어 프로그램이 실행되는 동안 일반적으로 변경할 수 없습니다. 이는 메모리 내에서 코드가 침범되거나 변경되는 것을 방지해 프로그램의 안정성을 보장합니다. 그리고 이 영역은 프로그램이 실행되는 동안 계속 메모리에 상주하며, 프로그램이 종료될 때까지 유지됩니다.

코드 영역에는 실제로 실행되는 함수와 명령어들의 코드가 저장되지만, 이들은 메모리의 스택 영역에 쌓이는 것이 아니라 별도의 고정된 메모리 영역에 위치합니다. 함수의 코드 자체는 스택에 쌓이지 않고, 함수가 호출될 때 그 함수의 실행을 위한 정보(매개변수, 지역 변수, 복귀 주소 등)만 스택 프레임 내에 스택에 쌓이게 됩니다.

### 힙(Heap)

힙 영역은 프로그래머가 직접 관리할 수 있는 메모리 영역입니다. 
힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다. 그래서 할당 후 해제를 하지 않으면 메모리 누수(memory leak)가 발생할 수 있습니다.

## 동적 할당

### 동적 할당의 필요성

C 언어에서 배열을 선언할 때, 배열의 크기는 보통 컴파일 시에 결정되어야 합니다. 예를 들어, int score[5];와 같은 선언은 컴파일 시에 score 배열이 5개의 int 값을 저장할 공간(총 20바이트, 각 int는 4바이트)을 필요로 한다는 것을 명시합니다. 그러나 int score[n];처럼 배열의 크기를 실행 시간에 결정되는 변수 n으로 지정하면, 컴파일러는 이 배열이 얼마나 많은 메모리를 필요로 하는지 알 수 없습니다.

이러한 경우, 배열의 크기가 실행 시간에 결정될 때 동적 할당을 사용합니다. 동적 할당은 프로그램이 실행되는 동안(런타임) 메모리의 크기를 할당하고 해제할 수 있게 해줍니다.

### malloc과 메모리

malloc을 사용하여 메모리를 할당하면 힙 영역에 메모리가 할당되고 해당 메모리 시작 주소를 반환합니다. 
이때 반환된 주소를 포인터 변수에 저장해야 합니다. 만약 malloc은 메모리를 할당할 수 없는 경우 NULL을 반환합니다.

```c
int *score = (int *)malloc(sizeof(int) * 5);
```

여기서, score는 8바이트 크기의 포인터 변수입니다. 포인터의 크기가 8바이트라는 것은 일반적으로 64비트 시스템에서의 포인터 크기를 의미합니다. 
score는 지역 변수이므로 스택(Stack) 영역에 저장되고, malloc으로 할당된 메모리(힙 영역에 있는)를 가리키게 됩니다.

주의할 점은 score 포인터 변수의 경우 함수가 종료되면 스택 프레임이 제거되어 스택 영역에 저장되었던 score 변수도 함께 제거됩니다. 
그러나 score가 가리키고 있는 메모리는 힙 영역에 저장되어 있으므로 함수가 종료되어도 메모리는 계속 유지됩니다. 
그래서 score가 가리키고 있는 메모리를 해제하기 위해서는 free 함수를 사용해야 합니다.

### 2차원 배열 

2차원 배열은 사실 배열의 배열입니다. 예를 들어, int 형의 2차원 배열을 동적으로 할당하려면 먼저 각 행에 대한 포인터를 저장할 포인터 배열을 할당하고, 각 행에 대한 실제 int 배열을 할당해야 합니다.

```c
int **p = malloc(rows * sizeof(int*)); // 각 행에 대한 포인터를 저장할 공간 할당

for (int i = 0; i < rows; i++) 
{
    p[i] = malloc(cols * sizeof(int)); // 각 행의 실제 정수 배열 할당
}
```

p는 int 포인터의 포인터로, 각각의 p[i]는 int 배열의 시작 주소를 저장합니다.

**2차원 배열의 접근 방법**

1. 인덱스로 접근하기: p[i][j]는 i번째 행과 j번째 열에 있는 요소를 나타냅니다.

2. 포인터 연산으로 접근하기: *(p[i] + j)는 p[i]에서 시작하여 j만큼 떨어진 위치의 요소를 가리키므로 p[i][j]와 같습니다.

```c
p[0][1] == *(p[0] + 1)
```

![two_dimensional_array](image/two_dimensional_array.png)
